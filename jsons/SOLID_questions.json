{
  "questions": [
    {
      "correctAnswer": "Dependency Inversion Principle",
      "question": "Which principle states that high-level modules should depend on abstractions rather than concrete implementations?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Dependency Inversion Principle",
        "Interface Segregation Principle"
      ]
    },
    {
      "correctAnswer": "Interface Segregation Principle",
      "question": "Which principle recommends breaking large interfaces into smaller, more specific ones?",
      "answers": [
        "Liskov Substitution Principle",
        "Interface Segregation Principle",
        "Open/Closed Principle",
        "Single Responsibility Principle"
      ]
    },
    {
      "correctAnswer": "Abstractions",
      "question": "According to DIP, what should both high-level and low-level modules depend on?",
      "answers": [
        "Concrete classes",
        "Abstractions",
        "Utility methods",
        "Global variables"
      ]
    },
    {
      "correctAnswer": "Reduced dependencies",
      "question": "What is a key benefit of following the Interface Segregation Principle?",
      "answers": [
        "Faster compilation",
        "Reduced dependencies",
        "Smaller executable size",
        "Lower memory usage"
      ]
    },
    {
      "correctAnswer": "Both should depend on abstractions",
      "question": "In the Dependency Inversion Principle, how should high-level and low-level modules relate to each other?",
      "answers": [
        "High-level depends on low-level",
        "Low-level depends on high-level",
        "Both should depend on abstractions",
        "They should be independent"
      ]
    },
    {
      "correctAnswer": "Client-specific interfaces",
      "question": "What does ISP recommend creating instead of general-purpose interfaces?",
      "answers": [
        "Client-specific interfaces",
        "Abstract base classes",
        "Friend classes",
        "Templated interfaces"
      ]
    },
    {
      "correctAnswer": "Business logic",
      "question": "What do high-level modules typically contain in an application?",
      "answers": [
        "Database connections",
        "Business logic",
        "UI components",
        "Network protocols"
      ]
    },
    {
      "correctAnswer": "Implementation details",
      "question": "What do low-level modules typically handle in an application?",
      "answers": [
        "User requirements",
        "Implementation details",
        "System architecture",
        "Business rules"
      ]
    },
    {
      "correctAnswer": "Violates ISP",
      "question": "What principle is violated when a class must implement methods it doesn't need?",
      "answers": [
        "Follows LSP",
        "Violates ISP",
        "Adheres to DIP",
        "Supports SRP"
      ]
    },
    {
      "correctAnswer": "Dependency injection",
      "question": "Which technique helps implement the Dependency Inversion Principle?",
      "answers": [
        "Method overloading",
        "Dependency injection",
        "Multiple inheritance",
        "Operator overloading"
      ]
    },
    {
      "correctAnswer": "Decouples modules",
      "question": "How does DIP improve software design?",
      "answers": [
        "Increases performance",
        "Decouples modules",
        "Reduces code size",
        "Simplifies debugging"
      ]
    },
    {
      "correctAnswer": "Multiple small interfaces",
      "question": "According to ISP, what is better than one large interface?",
      "answers": [
        "Multiple small interfaces",
        "A single abstract class",
        "Friend functions",
        "Global methods"
      ]
    },
    {
      "correctAnswer": "Changes propagate through layers",
      "question": "What problem does DIP help avoid in layered architectures?",
      "answers": [
        "Too many classes",
        "Changes propagate through layers",
        "Slow compilation",
        "Memory leaks"
      ]
    },
    {
      "correctAnswer": "Client should not depend on unused methods",
      "question": "What is the core idea behind the Interface Segregation Principle?",
      "answers": [
        "Interfaces should be large",
        "Client should not depend on unused methods",
        "All methods should be abstract",
        "Interfaces should inherit from classes"
      ]
    },
    {
      "correctAnswer": "Abstract classes or interfaces",
      "question": "What should modules depend on according to DIP?",
      "answers": [
        "Concrete implementations",
        "Abstract classes or interfaces",
        "Global functions",
        "Static methods"
      ]
    },
    {
      "correctAnswer": "Single Responsibility Principle",
      "question": "Which SOLID principle states that a module should have only one reason to change?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Interface Segregation Principle"
      ]
    },
    {
      "correctAnswer": "Open/Closed Principle",
      "question": "Which principle advocates that software should be open for extension but closed for modification?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Dependency Inversion Principle"
      ]
    },
    {
      "correctAnswer": "Liskov Substitution Principle",
      "question": "Which principle ensures that objects of a superclass can be replaced with objects of a subclass without affecting program correctness?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Interface Segregation Principle"
      ]
    },
    {
      "correctAnswer": "Interface Segregation Principle",
      "question": "Which principle suggests that clients should not be forced to depend on interfaces they do not use?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Interface Segregation Principle"
      ]
    },
    {
      "correctAnswer": "Dependency Inversion Principle",
      "question": "Which principle states that high-level modules should not depend on low-level modules, but both should depend on abstractions?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Dependency Inversion Principle"
      ]
    },
    {
      "correctAnswer": "Single Responsibility Principle",
      "question": "Which principle is violated when a class handles both report generation and email sending?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Interface Segregation Principle"
      ]
    },
    {
      "correctAnswer": "Open/Closed Principle",
      "question": "Which principle is violated when modifying an existing class to add new functionality instead of extending it?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Dependency Inversion Principle"
      ]
    },
    {
      "correctAnswer": "Liskov Substitution Principle",
      "question": "Which principle is violated when a subclass throws an exception for a method that the superclass defines without exceptions?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Interface Segregation Principle"
      ]
    },
    {
      "correctAnswer": "High Cohesion",
      "question": "What term describes a module where all elements are strongly related and focused on a single task?",
      "answers": [
        "Low Cohesion",
        "High Cohesion",
        "Tight Coupling",
        "Loose Coupling"
      ]
    },
    {
      "correctAnswer": "Loose Coupling",
      "question": "What term describes components in a system that are minimally dependent on each other?",
      "answers": [
        "Tight Coupling",
        "Loose Coupling",
        "High Cohesion",
        "Low Cohesion"
      ]
    },
    {
      "correctAnswer": "Single Responsibility Principle",
      "question": "Which principle is demonstrated by splitting a Calculator class into AdditionCalculator, SubtractionCalculator, etc.?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Dependency Inversion Principle"
      ]
    },
    {
      "correctAnswer": "Open/Closed Principle",
      "question": "Which principle is demonstrated by using a ColoredShape decorator to add color functionality without modifying Shape classes?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Interface Segregation Principle"
      ]
    },
    {
      "correctAnswer": "Liskov Substitution Principle",
      "question": "Which principle is violated when a RandomSorter subclass returns unsorted results while the Sorter superclass expects sorted results?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Interface Segregation Principle"
      ]
    },
    {
      "correctAnswer": "Interface Segregation Principle",
      "question": "Which principle is violated when a class implements a large interface but only uses a few of its methods?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Interface Segregation Principle"
      ]
    },
    {"correctAnswer": "Law of Demeter", "question": "Which principle states that a method should only call methods of its own class, its parameters, or objects it creates?", "answers": ["Single Responsibility Principle", "Law of Demeter", "Liskov Substitution Principle", "Interface Segregation Principle"]},
    {"correctAnswer": "Reduces coupling between classes", "question": "What is the primary benefit of following the Law of Demeter?", "answers": ["Improves performance", "Reduces coupling between classes", "Increases code reuse", "Simplifies inheritance"]},
    {"correctAnswer": "Train wreck", "question": "What is the term for a chain of method calls that violates the Law of Demeter?", "answers": ["Method chaining", "Train wreck", "Call stack", "Dependency chain"]},
    {"correctAnswer": "Only direct friends", "question": "According to the Law of Demeter, which objects can a method directly access?", "answers": ["Any object in the system", "Only static objects", "Only direct friends", "Only superclass objects"]},
    {"correctAnswer": "Delegation", "question": "What technique helps comply with the Law of Demeter by having intermediate objects handle requests?", "answers": ["Inheritance", "Polymorphism", "Delegation", "Encapsulation"]},
    {"correctAnswer": "Maintainability", "question": "Which software quality is most improved by following the Law of Demeter?", "answers": ["Performance", "Maintainability", "Memory efficiency", "Thread safety"]},
    {
      "correctAnswer": "Dependency Inversion Principle",
      "question": "Which principle is demonstrated by injecting NotificationService into Notifier instead of directly using EmailService?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Dependency Inversion Principle"
      ]
    },
    {
      "correctAnswer": "Single Responsibility Principle",
      "question": "Which principle is violated when a Report class handles both report generation and file saving?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Interface Segregation Principle"
      ]
    },
    {
      "correctAnswer": "Open/Closed Principle",
      "question": "Which principle is violated when adding a new shape type requires modifying an existing draw() method with if-else conditions?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Dependency Inversion Principle"
      ]
    },
    {
      "correctAnswer": "Liskov Substitution Principle",
      "question": "Which principle is violated when an ElectricVehicle subclass throws an exception for startEngine() while Vehicle superclass defines it normally?",
      "answers": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Interface Segregation Principle"
      ]
    },
    {
      "correctAnswer": "High Cohesion",
      "question": "Which design quality is achieved when a module's responsibilities are closely related and focused?",
      "answers": [
        "Low Cohesion",
        "High Cohesion",
        "Tight Coupling",
        "Loose Coupling"
      ]
    },
    {
      "correctAnswer": "Loose Coupling",
      "question": "Which design quality reduces the impact of changes in one component on other components?",
      "answers": [
        "Tight Coupling",
        "Loose Coupling",
        "High Cohesion",
        "Low Cohesion"
      ]
    }
  ]
}